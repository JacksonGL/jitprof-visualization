/*
 * Copyright 2016 University of California, Berkeley.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Author: Liang Gong
// do not remove the following comment
// JALANGI DO NOT INSTRUMENT

// jsPlumb plugin code for handling SVG elements
// code copied from https://blog.jsplumbtoolkit.com/posts/connecting-svg-shapes.html
function getSvgOffset(el) {
    return {
        left: el.get(0).getBoundingClientRect().left|0,
        top: el.get(0).getBoundingClientRect().top|0
    };
}

var offsetCalculators = {
    "CIRCLE": getSvgOffset,
    "ELLIPSE": getSvgOffset,
    "RECT": getSvgOffset
};

function getSvgSize(el) {
    /*
    var w = parseInt(el.getAttribute("width"), 10),
        h = parseInt(el.getAttribute("height"), 10);
    return [ w, h ];
    */
    return [
        el.get(0).getBoundingClientRect().width|0,
        el.get(0).getBoundingClientRect().height|0
    ];
}

// custom size calculators for SVG shapes.
var sizeCalculators = {
     "CIRCLE": getSvgSize,
     "ELLIPSE": getSvgSize,
     "RECT": getSvgSize
};

// store original jsPlumb prototype methods for getOffset and size.
var originalOffset = jsPlumbInstance.prototype.getOffset;
var originalSize = jsPlumbInstance.prototype.getSize;

 jsPlumbInstance.prototype.getOffset = function(el) {
     var tn = el.tagName.toUpperCase();
     if (offsetCalculators[tn]) {
         return offsetCalculators[tn]($(el));
     }
     else
         return $(el).offset();
 };

 jsPlumbInstance.prototype.getSize = function(el) {
     var tn = el.tagName.toUpperCase();
     if (sizeCalculators[tn]) {
         return sizeCalculators[tn]($(el));
     }
     else
         return [ $(el).outerWidth(), $(el).outerHeight() ];
 };

var connectionList = [];
var connStartId = 'none';
var cache = {
    gid: 'none',
    startElt: undefined,
    endElt: undefined,
    startPointLeft: -10,
    startPointTop: -10,
    endPointLeft: -10,
    endPointTop: -10
};

function clearConnDrawing() {
    // jsPlumb.detachEveryConnection();
    if (connectionList.length > 0) {
        jsPlumb.detach(connectionList.pop());
    }
}

function drawConnection() {
    if (connStartId === 'none') {
        return;
    }
    var startElt = document.getElementById(connStartId);
    var endElt;
    /*
    var endElt = document.getElementById('connection-end');
    if (endElt) {
        endElt.id = '';
    }
    */
    var elements = document.getElementsByClassName('styled-background');
    if (elements.length > 0) {
        endElt = elements[0];
        endElt.id = 'connection-end';
    } else {
        console.log('connection EndPoint undefined');
        endElt = undefined;
    }
    /*
    var gid_changed = false;
    if (cache.gid !== connStartId) {
        gid_changed = true;
        // need to reload elements
        cache.gid = connStartId;
        cache.startElt = document.getElementById(connStartId);
        if (cache.endElt !== undefined) {
            cache.endElt.id = '';
        }
        var elements = document.getElementsByClassName('styled-background');
        if (elements.length > 0) {
            cache.endElt = elements[0];
            cache.endElt.id = 'connection-end';
        } else {
            console.log('connection EndPoint undefined');
            cache.endElt = undefined;
        }
    }
    */
    /*
    var redraw = false;
    // check and update position of starting and ending point
    if (cache.gid !== 'none') {
        var startPointLeft = cache.startElt.getBoundingClientRect().left;
        var startPointTop = cache.startElt.getBoundingClientRect().top;
        var endPointLeft = cache.endElt.getBoundingClientRect().left;
        var endPointTop = cache.endElt.getBoundingClientRect().top;
        if (startPointTop !== cache.startPointLeft
            || startPointLeft !== cache.startPointLeft
            || endPointTop !== cache.endPointTop
            || endPointLeft !== cache.endPointLeft) {
            cache.startPointLeft = startPointLeft;
            cache.startPointTop = startPointTop;
            cache.endPointLeft = endPointLeft;
            cache.endPointTop = endPointTop;
            if (gid_changed === false) {
                console.log('repaint...')
                // jsPlumb.repaint(cache.gid);
                jsPlumb.repaintEverything();
            } else {
                redraw = true;
            }
        }
    }
            
    if (redraw === false) 
        return;
    */
    // clearConnDrawing();
    // console.log('rebuilding...')
    var inst = jsPlumb.getInstance({
        PaintStyle: {
            lineWidth: 2,
            strokeStyle: "yellow"
        },
        // Connector:[ "Bezier", { curviness: 30 } ],
        Endpoint: ["Dot", {
            radius: 6
        }],
        EndpointStyle: {
            fillStyle: "yellow"
        },
        Container: document.body,
        deleteEndpointsOnDetach: true
    });

    var conn = inst.connect({
        source: connStartId,
        target: "connection-end"
    });
    // inst.draggable(cache.startElt);
    // inst.draggable(cache.endElt);
    connectionList.unshift(conn);
    endElt.id = '';
    setTimeout(clearConnDrawing, 1500);
}

function createConnection(gid) {
    connStartId = gid;
    setTimeout(drawConnection, 10);
}

/*
function resetConnection() {
   clearConnDrawing();
   drawConnection();
}
*/

// setInterval(drawConnection, 200);